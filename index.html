<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Chess - Debug Mode</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Georgia', serif; }
        
        #ui-container {
            position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: none; z-index: 10;
        }
        
        #status {
            background: linear-gradient(to bottom, #3e2723, #21120f);
            color: #deb887;
            padding: 15px 40px;
            border-radius: 8px;
            font-size: 24px;
            font-weight: bold;
            border: 2px solid #8d6e63;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            display: inline-block;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 30px; font-weight: bold;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;
            z-index: 20;
        }
        
        .controls { margin-top: 15px; pointer-events: auto; }
        
        button {
            padding: 10px 20px; font-size: 16px; cursor: pointer; background: #5d4037; 
            color: #ffe0b2; border: 1px solid #8d6e63; border-radius: 4px;
            font-family: 'Georgia', serif; transition: background 0.2s;
        }
        button:hover { background: #795548; }
    </style>
    
    <!-- Three.js & Controls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <!-- Chess Logic -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

    <!-- GUI Library for Debugging -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
</head>
<body>

    <div id="loading">Loading 3D Models...</div>

    <div id="ui-container">
        <div id="status">White's Turn</div>
        <div class="controls">
            <button onclick="resetGame()">Reset Game</button>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const SQUARE_SIZE = 2;
        const OFFSET = -3.5 * SQUARE_SIZE; 
        
        // --- GLOBALS ---
        let scene, camera, renderer, controls;
        let game = new Chess();
        
        // Model Cache
        const loadedModels = {}; 
        const modelPaths = {
            'p': 'assets/pawn.glb',
            'r': 'assets/rook.glb',
            'n': 'assets/knight.glb',
            'b': 'assets/bishop.glb',
            'q': 'assets/queen.glb',
            'k': 'assets/king.glb'
        };

        // Debug Settings - FIXED VALUES
        const debugSettings = {
            pieceScale: 0.05,      // Fixed to 0.05
            pieceElevation: 0.26,  // Fixed to 0.26
            knightRotation: 90
        };

        // Mesh Containers
        let boardMeshes = {};
        let pieceMeshes = {};
        let highlightMeshes = [];
        let capturedMeshes = [];
        
        let selectedSquare = null;
        let isAiThinking = false;

        // --- MATERIALS ---
        const matWoodLight = new THREE.MeshStandardMaterial({ color: 0xE6BF83, roughness: 0.3, metalness: 0.1 });
        const matWoodDark = new THREE.MeshStandardMaterial({ color: 0x593E1A, roughness: 0.3, metalness: 0.1 });
        const matHighlight = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
        
        const matPieceWhite = new THREE.MeshStandardMaterial({ color: 0xFFFFF0, roughness: 0.2, metalness: 0.2 });
        const matPieceBlack = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2, metalness: 0.4 });
        const matBoardBorder = new THREE.MeshStandardMaterial({ color: 0x3E2723, roughness: 0.4 });

        init();

        function init() {
            // 1. SCENE
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            // 2. CAMERA
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 25, 18);
            camera.lookAt(0, 0, 0);

            // 3. RENDERER
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 4. CONTROLS
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // 5. LIGHTING
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);

            const spotLight = new THREE.SpotLight(0xffeebb, 1.2);
            spotLight.position.set(10, 30, 10);
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 2048;
            spotLight.shadow.mapSize.height = 2048;
            scene.add(spotLight);

            // 6. DEBUG GUI
            initGUI();

            // 7. ASYNC LOADING START
            loadModels().then(() => {
                document.getElementById('loading').style.display = 'none';
                createBoardVisuals();
                createSideTrays();
                updateBoardState();
                animate();
            });

            // 8. LISTENERS
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);
        }

        function initGUI() {
            const gui = new dat.GUI();
            const folder = gui.addFolder('Piece Adjustments');
            
            folder.add(debugSettings, 'pieceScale', 0.01, 3.0).name('Size (Scale)').onChange(updateAllPieceVisuals);
            folder.add(debugSettings, 'pieceElevation', -1.0, 1.0).name('Elevation (Y)').onChange(updateAllPieceVisuals);
            
            folder.open();
        }

        function updateAllPieceVisuals() {
            for (let key in pieceMeshes) {
                const mesh = pieceMeshes[key];
                mesh.scale.set(debugSettings.pieceScale, debugSettings.pieceScale, debugSettings.pieceScale);
                mesh.position.y = debugSettings.pieceElevation;
            }
            capturedMeshes.forEach(mesh => {
                mesh.scale.set(debugSettings.pieceScale, debugSettings.pieceScale, debugSettings.pieceScale);
                mesh.position.y = debugSettings.pieceElevation;
            });
        }

        // --- ASSET LOADING ---
        function loadModels() {
            const loader = new THREE.GLTFLoader();
            const promises = [];

            for (const [key, path] of Object.entries(modelPaths)) {
                promises.push(new Promise((resolve, reject) => {
                    loader.load(path, (gltf) => {
                        const model = gltf.scene;
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true; 
                                child.receiveShadow = true;
                            }
                        });
                        loadedModels[key] = model;
                        resolve();
                    }, undefined, (error) => {
                        console.error('Error loading ' + path, error);
                        resolve(); 
                    });
                }));
            }
            return Promise.all(promises);
        }

        // --- GEOMETRY HELPERS ---

        function getPieceMesh(type, color) {
            const template = loadedModels[type];
            let mesh;

            if(!template) {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5,1,0.5), matPieceWhite);
            } else {
                mesh = template.clone();
                const targetMat = color === 'w' ? matPieceWhite : matPieceBlack;

                mesh.traverse((node) => {
                    if (node.isMesh) {
                        node.material = targetMat;
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
            }

            mesh.scale.set(debugSettings.pieceScale, debugSettings.pieceScale, debugSettings.pieceScale);

            if (type === 'n') { 
                const rotRad = (debugSettings.knightRotation * Math.PI) / 180;
                mesh.rotation.y = color === 'w' ? rotRad : -rotRad;
            }

            return mesh;
        }

        // --- VISUALS GENERATION ---
        
        function createBoardVisuals() {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const geo = new THREE.BoxGeometry(SQUARE_SIZE, 0.5, SQUARE_SIZE);

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const isLight = (r + c) % 2 === 0;
                    const mat = isLight ? matWoodDark : matWoodLight; 
                    const square = new THREE.Mesh(geo, mat);
                    
                    const x = c * SQUARE_SIZE + OFFSET;
                    const z = r * SQUARE_SIZE + OFFSET;
                    square.position.set(x, 0, z);
                    square.receiveShadow = true;

                    square.userData = { name: files[c] + (8 - r), type: 'square' };
                    boardMeshes[files[c] + (8 - r)] = square;
                    scene.add(square);
                }
            }
            
            const borderGeo = new THREE.BoxGeometry(SQUARE_SIZE * 8 + 1, 0.4, SQUARE_SIZE * 8 + 1);
            const border = new THREE.Mesh(borderGeo, matBoardBorder);
            border.position.y = -0.25;
            border.receiveShadow = true;
            scene.add(border);
        }

        function createSideTrays() {
            const trayGeo = new THREE.BoxGeometry(4, 0.2, 14);
            const leftTray = new THREE.Mesh(trayGeo, matBoardBorder);
            leftTray.position.set(-11, -0.2, 0);
            leftTray.receiveShadow = true;
            scene.add(leftTray);

            const rightTray = new THREE.Mesh(trayGeo, matBoardBorder);
            rightTray.position.set(11, -0.2, 0);
            rightTray.receiveShadow = true;
            scene.add(rightTray);
        }

        // --- GAME STATE UPDATES ---

        function updateBoardState() {
            for (let key in pieceMeshes) {
                scene.remove(pieceMeshes[key]);
            }
            pieceMeshes = {};

            const board = game.board(); 
            board.forEach((row, rIndex) => {
                row.forEach((piece, cIndex) => {
                    if (piece) {
                        const mesh = getPieceMesh(piece.type, piece.color);
                        
                        const x = cIndex * SQUARE_SIZE + OFFSET;
                        const z = rIndex * SQUARE_SIZE + OFFSET;
                        
                        mesh.position.set(x, debugSettings.pieceElevation, z);
                        
                        const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                        const squareName = files[cIndex] + (8 - rIndex);
                        
                        mesh.userData = { name: squareName, type: 'piece', color: piece.color, pieceType: piece.type };
                        pieceMeshes[squareName] = mesh;
                        scene.add(mesh);
                    }
                });
            });

            updateCapturedVisuals();
        }

        function updateCapturedVisuals() {
            capturedMeshes.forEach(m => scene.remove(m));
            capturedMeshes = [];

            const totals = { p:8, n:2, b:2, r:2, q:1 }; 
            const active = { w: { p:0, n:0, b:0, r:0, q:0 }, b: { p:0, n:0, b:0, r:0, q:0 } };

            game.board().forEach(row => {
                row.forEach(p => {
                    if (p && p.type !== 'k') active[p.color][p.type]++;
                });
            });

            const types = ['p', 'n', 'b', 'r', 'q'];
            
            let wRow = 0, wCol = 0;
            types.forEach(type => {
                const missingCount = Math.max(0, totals[type] - active.w[type]);
                for(let i=0; i<missingCount; i++){
                    const mesh = getPieceMesh(type, 'w');
                    mesh.position.set(-12 + (wCol * 1.5), debugSettings.pieceElevation, -6 + (wRow * 1.5));
                    scene.add(mesh);
                    capturedMeshes.push(mesh);
                    wRow++;
                    if(wRow > 7) { wRow = 0; wCol++; }
                }
            });

            let bRow = 0, bCol = 0;
            types.forEach(type => {
                const missingCount = Math.max(0, totals[type] - active.b[type]);
                for(let i=0; i<missingCount; i++){
                    const mesh = getPieceMesh(type, 'b');
                    mesh.position.set(12 - (bCol * 1.5), debugSettings.pieceElevation, 6 - (bRow * 1.5)); 
                    scene.add(mesh);
                    capturedMeshes.push(mesh);
                    bRow++;
                    if(bRow > 7) { bRow = 0; bCol++; }
                }
            });
        }

        // --- INTERACTION (FIXED WITH BETTER RAYCASTING) ---

        function onPointerDown(event) {
            if (game.game_over() || isAiThinking) return;

            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            // Get all intersected objects
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            console.log('Click detected, intersects:', intersects.length);

            if (intersects.length > 0) {
                // Try to find what we clicked on
                let clickedSquare = null;
                let clickedPiece = null;
                let clickedHighlight = null;

                // Check all intersected objects
                for (let i = 0; i < intersects.length; i++) {
                    let obj = intersects[i].object;
                    
                    // Check the object itself
                    if (obj.userData && obj.userData.name) {
                        if (obj.userData.type === 'highlight') {
                            clickedHighlight = obj.userData.name;
                            break; // Highlights have priority
                        } else if (obj.userData.type === 'piece') {
                            clickedPiece = { square: obj.userData.name, color: obj.userData.color };
                        } else if (obj.userData.type === 'square') {
                            clickedSquare = obj.userData.name;
                        }
                    }
                    
                    // Check parent objects (for GLTF models)
                    let parent = obj.parent;
                    while (parent && parent !== scene) {
                        if (parent.userData && parent.userData.name) {
                            if (parent.userData.type === 'piece') {
                                clickedPiece = { square: parent.userData.name, color: parent.userData.color };
                                break;
                            }
                        }
                        parent = parent.parent;
                    }
                    
                    if (clickedPiece) break;
                }

                console.log('Clicked:', { clickedHighlight, clickedPiece, clickedSquare });

                // Handle the click based on what was found
                if (clickedHighlight) {
                    // Clicked on a highlight - make the move
                    console.log('Moving to highlighted square:', clickedHighlight);
                    attemptMove(selectedSquare, clickedHighlight);
                } else if (clickedPiece) {
                    // Clicked on a piece
                    if (game.turn() === 'w' && clickedPiece.color === 'w') {
                        // Select white piece on white's turn
                        console.log('Selecting white piece at:', clickedPiece.square);
                        selectSquare(clickedPiece.square);
                    } else if (selectedSquare) {
                        // Try to capture or move
                        console.log('Attempting move from', selectedSquare, 'to', clickedPiece.square);
                        attemptMove(selectedSquare, clickedPiece.square);
                    }
                } else if (clickedSquare) {
                    // Clicked on empty square
                    if (selectedSquare) {
                        console.log('Moving to empty square:', clickedSquare);
                        attemptMove(selectedSquare, clickedSquare);
                    } else {
                        clearHighlights();
                        selectedSquare = null;
                    }
                }
            } else {
                console.log('Clicked outside board');
                clearHighlights();
                selectedSquare = null;
            }
        }

        function selectSquare(squareName) {
            selectedSquare = squareName;
            clearHighlights();
            const moves = game.moves({ square: squareName, verbose: true });
            moves.forEach(move => {
                const targetMesh = boardMeshes[move.to];
                if (targetMesh) {
                    const highlight = new THREE.Mesh(new THREE.PlaneGeometry(1.8, 1.8), matHighlight);
                    highlight.rotation.x = -Math.PI / 2;
                    highlight.position.set(targetMesh.position.x, 0.26, targetMesh.position.z);
                    highlight.userData = { name: move.to, type: 'highlight' };
                    scene.add(highlight);
                    highlightMeshes.push(highlight);
                }
            });
        }

        function clearHighlights() {
            highlightMeshes.forEach(m => scene.remove(m));
            highlightMeshes = [];
        }

        function attemptMove(from, to) {
            const move = game.move({ from: from, to: to, promotion: 'q' });
            if (move === null) {
                selectedSquare = null;
                clearHighlights();
                return;
            }
            updateBoardState();
            clearHighlights();
            selectedSquare = null;
            updateStatus();
            if (!game.game_over()) {
                isAiThinking = true;
                document.getElementById('status').innerText = "Computer Thinking...";
                setTimeout(makeAiMove, 500); 
            }
        }

        function makeAiMove() {
            const possibleMoves = game.moves();
            if (possibleMoves.length === 0) return;
            let chosenMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
            const detailedMoves = game.moves({ verbose: true });
            const captureMoves = detailedMoves.filter(m => m.captured);
            if (captureMoves.length > 0) {
                chosenMove = captureMoves[Math.floor(Math.random() * captureMoves.length)];
            }
            game.move(chosenMove);
            updateBoardState();
            updateStatus();
            isAiThinking = false;
        }

        function updateStatus() {
            let statusText = '';
            if (game.in_checkmate()) statusText = "Checkmate!";
            else if (game.in_draw()) statusText = "Draw!";
            else if (game.in_check()) statusText = "Check!";
            else statusText = (game.turn() === 'w' ? "White's Turn" : "Black's Turn");
            document.getElementById('status').innerText = statusText;
        }
        
        function resetGame() {
            game.reset();
            updateBoardState();
            clearHighlights();
            selectedSquare = null;
            isAiThinking = false;
            updateStatus();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>